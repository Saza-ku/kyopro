{
	"kyopro": {
		"prefix": "kyopro",
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define rep(i, N) for(int i = 0; i < N; i++)",
			"#define mkp make_pair",
			"#define pb push_back",
			"",
			"using ll = long long;",
			"",
			"const int INF = 1e9;",
			"const ll INFL = 1e18;",
			"const int MOD = 1e9 + 7;",
			"",
			"int main() {",
			"  $0",
			"}",
			"",
		],
		"description": "普通の競プロセット",
	},

	"setprecision": {
		"prefix": "setprecision",
		"body": [
			"cout << fixed << setprecision(14);",
		],
		"description": "double の桁数を固定",
	},

	"repeat_squaring": {
		"prefix": "rep_sq",
		"body": [
			"ll repeat_squaring(ll x, ll n, ll mod) {",
			"  x %= mod;",
			"  if(n == 0) {",
			"    return 1;",
			"  }",
			"  else if(n % 2 == 0) {",
			"    long long t = repeat_squaring(x, n / 2, mod);",
			"    return t * t % mod;",
			"  }",
			"  else {",
			"    return x * repeat_squaring(x, n - 1, mod) % mod;",
			"  }",
			"}",
		],
		"description": "繰り返し二乗法",
	},

	"mod_rev": {
		"prefix": "mod_rev",
		"body": [
			"ll mod_rev(ll N, ll mod) {",
			"  repeat_squaring(n, mod - 2, mod);",
			"}",
		],
		"description": "MOD の除算",
	},

	"factorial_mod": {
		"prefix": "fac_mod",
		"body": [
			"ll fac_mod(ll m, ll mod) {",
			"  static vector<ll> f_(10000000, -1);",
			"  f_[0] = 1;",
			"  if (f_[m] != -1) {",
			"    return f_[m];",
			"  }",
			"  return f_[m] = fac_mod(m-1, mod) * m % mod;",
			"}",
		],
		"description": "MOD の階乗",
	},

	"combination_mod": {
		"prefix": "com_mod",
		"body": [
			"ll com_mod(ll n, ll k, ll mod) {",
			"  ll ret = fac_mod(n, mod) * mod_rev(fac_mod(k, mod), mod) % mod;",
			"  ret = ret * mod_rev(fac_mod(n - k, mod), mod) % mod;",
			"  return ret;",
			"}",
		],
		"description": "MOD の二項係数"
	},

	"union_find": {
		"prefix": "union_find",
		"body": [
			"struct union_find{",
			"  vector<ll> par;",
			"  vector<ll> s;",
			"",
			"  union_find(long long N) : par(N), s(N) {",
			"    rep (i, N) {",
			"      par[i] = i;",
			"      s[i] = 1;",
			"    }",
			"  }",
			"",
			"  ll root(ll i){",
			"    if (par[i] == i) return i;",
			"    par[i] = root(par[i]);",
			"    return root(par[i]);",
			"  }",
			"",
			"  ll size(ll i){",
			"    return s[root(i)];",
			"  }",
			" ",
			"  bool same(ll x, ll y){",
			"    return root(x) == root(y);",
			"  }",
			"  ",
			"  void unite(ll x, ll y){",
			"    if(!same(x,y)){",
			"      ll rx = root(x);",
			"      ll ry = root(y);",
			"      par[rx] = par[ry];",
			"      s[ry] = s[rx] + s[ry];",
			"    }",
			"  }",
			"};",
		]
	},

	"dijkstra": {
		"prefix": "dijkstra",
		"body": [
			"vector<int> dijkstra(vector<vector<edge>> &g, int s) {",
			"  int n = g.size();",
			"  vector<int> ret(n, INF);",
			"  vector<bool> seen(n, false);",
			"  priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;",
			"  q.push(mkp(0, s));",
			"",
			"  while (!q.empty()) {",
			"    int d, u;",
			"    tie(d, u) = q.top();",
			"    q.pop();",
			"    if (seen[u]) continue;",
			"    ret[u] = d;",
			"    seen[u] = true;",
			"",
			"    for (auto v : g[u]) {",
			"      if (seen[v.to]) continue;",
			"      if (d + v.cost > ret[v.to]) continue;",
			"      ret[v.to] = d + v.cost;",
			"      q.push(mkp(ret[v.to], v.to));",
			"    }",
			"  }",
			"",
			"  return ret;",
			"}",
		],
		"description": "ダイクストラ法",
	},

	"edge": {
		"prefix": "edge",
		"body": [
			"struct edge {",
			"  int to;",
			"  int cost;",
			"};",
		],
		"description": "グラフの辺",
	},

	"binary_search": {
		"prefix": "binary_search",
		"body": [
			"ll binary_search(ll ng, ll ok, function<bool(ll)> is_ok) {",
			"  while (abs(ok - ng) > 1) {",
			"    ll mid = (ok + ng) / 2;",
			"    if (is_ok(mid)) {",
			"      ok = mid;",
			"    }",
			"    else {",
			"      ng = mid;",
			"    }",
			"  }",
			"  return ok;",
			"}",
		],
		"description": "めぐる式ニ分探索",
	},

	"gcd": {
		"prefix": "gcd",
		"body": [
			"ll gcd(ll m, ll n) {",
			"  ll a = max(m, n);",
			"  ll b = min(m, n);",
			"  ll r = a % b;",
			"",
			"  while(r != 0){",
			"    a = b;",
			"    b = r;",
			"    r = a % b;",
			"  }",
			"",
			"  return b;",
			"}",
		],
		"description": "最大公約数",
	},
}